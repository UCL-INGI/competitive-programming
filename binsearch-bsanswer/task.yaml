accessible: false
author: ''
context: |-
    Now that we have seen two basic examples of binary search we are going to generalize it and see how it can be applied to solve more complicated problems.

    Let's start by rewriting the :code:`integerSqrt` as follows:

    .. code:: java

        static int integerSqrt(int n) {
            long L = 0;
            long R = n + 1;
            while(R - L >= 2) {
                long M = (L + R) / 2;
                if(check(M, n)) L = M; // dismiss all values < M
                else R = M; // dismiss all values > M
            }
            return (int)L;
        }

        static boolean check(long x, int n) {
            return x * x <= n;
        }

    It is essentially the same code, except that we extracted the check condition. When we read it like that we can see that what the code is doing is finding the maximum value such that the condition :code:`check` is true. And it will work because :code:`check` has the following property:

        When we vary :math:`x`, it is always *true* util some point and then always *false* after that point.

    The following image illustrrates this:

    .. image:: binsearch-bsanswer/binsearch.png

    |

    This means that we can actually use binary search to solve **any problem** in which we seek the largest value that satisfies some given property as long as that truth value of that property is
environment: dafny
evaluate: best
groups: false
input_random: '0'
limits:
    output: '2'
    memory: '100'
    time: '30'
name: Binary search - Search on the answer
network_grading: false
problems: {}
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
