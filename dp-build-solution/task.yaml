accessible: true
author: ''
context: |-
    We now solved the Knapsack problem in two different ways: using top-down and bottom-up dp. However, both those solutions only give the *value* of the solution.

    Here we will see how we can actually recontruct the set of items that are taken. We will do this for both the top-down and the bottom-up solution.

    Let's start with the top-down solution. In order to be able to build the solution, we will remember for each state what was the *action* that lead us to the optimal value. Then we will trace back those actions from the initial state :math:`(0, C)`.

    In this problem there are two actions: skip an item and take an item. To make the code more readable but not require to create a lot of objects in memory, we will simply define those as two integers with the names SKIP and TAKE.

    Also, we will need to keep track of which action lead to each of the states. We an do this with a matrix :math:`action` of size :math:`n` by :math:`C + 1`.

    .. code:: java

      static int SKIP = 0, TAKE = 1;
      static Integer[][] action;

    Our previous code ended with:

    .. code:: java

        ...
        // memorize the value of state (i, c)
        memo[i][c] = Math.max(skip, take);
        return memo[i][c]
      }

    This is where we know what is the best action. It corresponds to the maximum between :math:`skip` and :math:`take`. So if :math:`skip \geq take` then we know that the action to do is SKIP and otherwise it is TAKE. We can easily change it to set the best action as follows:

    .. code:: java

        ...
        // memorize the value of state (i, c) and set action
        if(skip >= take) {
          memo[i][c] = skip;
          action[i][c] = SKIP;
        } else {
          memo[i][c] = take;
          action[i][c] = TAKE;
        }
        return memo[i][c]
      }

    To build the set of items we start from state :math:`(0, C)` and check what is the value of :math:`action[0][C]`. If it is SKIP then we know that item :math:`0` is not in the optimal solution. Thus we ignore it and go to state :math:`(1, C)`. Otherwise, if it is TAKE, then we know item :math:`0` is in the optimal solution. We add it to the list of items in the solution and go to state :math:`(1, C - w_0)`.

    We repeat this process until we either run out of items or out of space in the knapsack.

    .. code:: java

        static LinkedList<Integer> buildSolution() {
          int i = 0;
          int c = C;
          LinkedList<Integer> taken = new LinkedList<>();
          while(i < n && c >= 0) {
            if(action[i][c] == TAKE) {
              taken.add(i);
              c -= w[i];
            }
            i += 1;
          }
          return taken;
        }
environment: scapy
evaluate: best
groups: false
limits:
    memory: '100'
    output: '2'
    time: '30'
name: DP - Knapsack, build the solution
network_grading: false
order: 4
problems:
    dp-build-solution:
        name: ''
        header: ''
        type: code-file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
weight: 1.0
