accessible: true
author: ''
context: |+
    We are now going to discuss sparse tables. Sparse table are great at answering a wide range of queries. We will start by discussing range minimum queries (RMQ) and then see how we can extend them to other kind of queries.

    **The range minimum query problem on an fixed array** :math:`a` **of length** :math:`n`:

    - Input: a range :math:`[i, j]`.
    - Output: :math:`\min (a[i], a[i + 1], \ldots, a[j])`

    *Note:* whenever we mention a range :math:`[i, j]` we assume that :math:`i \leq j`.

    There are several possible solution for this problem. Using sparse table we will be able to solve it in :math:`\langle O(n \cdot \log(n)), O(1) \rangle`.

    The general idea to solve this problem is similar to the one we used for the range sum query problem: *precompute the solution on some ranges and use express any range as a funcion of the precomputed ranges*.

    Let's define a states space consisting of the pairs :math:`(i, j)` and subproblems :math:`rmq(i, j)` as

    ..  math::

        rmq(i, j) = \min(a[i], a[i + 1], \ldots, a[j])

    The :math:`\min` funcion has a nice property that if we have to ranges :math:`[i, k_1]` and :math:`[k_2, j]` then, even if those ranges overlap, taking the minimum of both will yield the minimum of range :math:`[i, j]`, providade that these two ranges cover it (:math:`k_2 \leq k_1`). More formaly, if :math:`k_2 \leq k_1`, then

    .. math::

       rmq(i, j) = \min(rmq(i, k_1), rmq(k_2, j))

    This means that all we need is to precompute :math:`rmq` on a set of ranges such that *any range can be covered by two of those ranges, eventually with overlap*.

environment: pyjavacpp
evaluate: best
groups: false
limits:
    time: '1000'
    memory: '1000'
    output: '100'
name: 'DP - Data structures: sparse table for RMQ'
network_grading: false
problems:
    file:
        type: file
        header: ''
        name: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
