accessible: false
author: ''
context: |-
    We are now going to study another graph exploration algorithm called depth-first search (DFS). As we will DFS is extremely useful and with it we can solve a wide number of graph related problems.

    In DFS we start from a source node a then recursively visit each of its neighbors. Because of this recursive behavior, after we select the first neighbor :math:`u` of :math:`v` to be explored, the other neighbors of :math:`v` will only be considered after we have finished visiting the whole subgraph that is reachable from :math:`u`. This is the reason why the algorithm is called **depth-first** search. To better ilustrate this consider the following example.


    .. image:: graphs-dfs/dfs.gif


    Coding this algorithm is very simple as shown in the following code:

    .. code:: java

        static LinkedList<Integer>[] g;
        static boolean[] visited;

        static void dfs(int u) {
            visited[u] = true;
            for(int v : g[u]) if(!visited[v]) dfs(v);
        }

    If we execute the following code:

    .. code:: java

        ...
        boolean[] visited = new boolean[g.length];
        dfs(0);

    Then visited will be set to :math:`true` for every node that is reachable from node :math:`0`. In this way, DFS is a much more compact way of coding an algorithm to check for path existance.

    So far this does not really give us something new. There are several ways in which we can extend this algorithm in order to solve different problems.

    Before we do so, it is often convinient to have a more informative state of each node during the search rather than a simple flag sayinh whether a node as been visited or not. We will start by replacing the :code:`visited` array by an array of integers called :code:`state` and define 3 possible states:

    .. code:: java

        static final int UNV = 0, OPEN = 1, CLOSED = 2;

    These 3 states have the following semantics:

    - :math:`state[u] = \textit{UNV}` : node :math:`u` has not been visited before. This corresponds to :math:`visited[u] = false` from before.
    - :math:`state[u] = \textit{OPEN}` : node :math:`u` has been visited but not all of its outgoing edges have been visited.
    - :math:`state[u] = \textit{CLOSED}` : means that all the edges going out of  :math:`u` have been visited.

    To extend the previous code to use this states respecting these semantics is quite simple. Every node should start with the state :math:`\textit{UNV}`. Then the first line should set the state to :math:`\textit{OPEN}` since at this point the node is visited but we did not yet visit any of its outgoing edges. Finally, after the :code:`for` loop finished we should set the state to :math:`\textit{CLOSED}`. We will also add an array :math:`parent` to keep for each node, who visited him.

    .. code:: java

        static int[] state;
        static int[] parent;

        static void dfsVisit(int u) {
            state[u] = OPEN;
            for(int v : g[u]) {
                if(state[u] == UNV) {
                    parent[u] = v;
                    dfs(v);
                }
            }
            state[u] = CLOSED;
        }

    *Note:* In Java when you create the :math:`state` array every value is initialized to :math:`0 = UNV`. Therefore nothing needs to be done. In some other languagues you need to make sure that you set the value of every node :math:`UNV` before you start the search.

    As a first application of DFS we are going to see how we can use the states to simply check whether a directed graph contains a cycle.


    .. image:: graphs-dfs/states.gif


    To do so, observe that during the execution of :code:`dfsVisit` on a node :math:`u`, if any node :math:`v` is :math:`OPEN` at that moment then there exists a path from :math:`v` to :math:`u`. This is so because since :math:`v` is still open and we are at node :math:`u` then :math:`v` must be an ancestor of :math:`u` in the DFS tree.

    Therefore if during the :code:`for` loop at node :math:`u` we find a neighbor :math:`v` that is :math:`OPEN` we must have a cycle in the graph since as we just observed this means that there is a path from :math:`v` to :math:`u` and this path together with the edge :math:`(u, v)` must form a cylce.

    |

    .. image:: graphs-dfs/tree.gif
environment: java8scala
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    memory: '1000'
    time: '1000'
name: 'Graphs - Depth-first search: cycle finding'
network_grading: false
problems:
    file:
        name: ''
        header: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
