/run.py: |-
    import sys
    import os
    import checkers
    import time
    import math
    from run_tools import *

    """
    CONFIG
    """
    taskname = 'file'
    solname = 'yunoacsol'
    timelimit = 4
    checker = checkers.diff_check
    """
    END OF CONFIG
    """

    filename = None
    local = False
    if sys.argv[1] == '1':
      local = True
      filename = sys.argv[2]

    if not local:
      from inginious import feedback
      judging  = judge_java('yunoacsol', checker, 10000, './tests', False)
      max_time = judging.get_max_runtime()
      if max_time > timelimit:
        timelimit += max_time - timelimit

    name = None
    ext = None
    files_before = set()

    if local:
      for fn in os.listdir('./'):
        files_before.add(fn)
      os.system('cp ./private/{0} ./{0}'.format(filename))
    else:
      os.system('getinput {0}:filename > tmp'.format(taskname))
      f = open('tmp', 'r')
      filename = f.readlines()[0].strip()

    ext = filename.split('.')[1]
    name = filename.split('.')[0]

    if(ext == 'java'):
      print('received java solution')
      if not local:
        os.system('getinput {0} > {1}.java'.format(taskname, name))
      judging = judge_java(name, checker, timelimit)
      print('finished judging java')
    elif(ext == 'cpp'):
      print('received cpp solution')
      if not local:
        os.system('getinput {0} > {1}.cpp'.format(taskname, name))
      judging = judge_cpp(name, checker, timelimit)
      print('finished judging cpp')
    elif(ext == 'py'):
      print('received python solution')
      if not local:
        os.system('/bin/bash -c "getinput {0} > {1}.py"'.format(taskname, name))
      judging = judge_py(name, checker, timelimit)
      print('finished judging python')


    if local:
      for fn in os.listdir('./'):
        if not fn in files_before:
          print('deleting {0}'.format(fn))
          os.system('rm ./{0}'.format(fn))
      print(judging.produce_feedback_message())
    else:
      if judging.is_accepted():
        feedback.set_global_result("success")
      else:
        feedback.set_global_result("failed")
      feedback.set_global_feedback(judging.produce_feedback_message())
/run_tools.py: |-
    import time
    import os
    import checkers
    import subprocess
    from subprocess import TimeoutExpired

    def execute_command(cmd, verbose = True):
      if(verbose): print('executing: {0}'.format(cmd))
      subprocess.run(cmd, shell = True)

    def read_first_line(filename):
      f = open(filename, 'r')
      return f.readlines()[0]

    """
    Checks whether the given file is empty.
    """
    def is_empty_file(fn):
      return os.path.getsize(fn) == 0

    """
    Creates a list containing all lines from a given file.
    """
    def readlines(fn):
      f = open(fn, 'r')
      lines = [line.strip() for line in f.readlines()]
      return lines

    """
    Given a list of strings, create a string containing
    all those strings separated by newlines for INGInious
    presentation.
    """
    def format_for_output(lines):
      return '\n\n'.join(lines)

    """
    Compiles a java code.
    """
    def compile_java(filename, verbose = True):
      if(verbose): print('compiling java')
      os.system('> err')
      os.system('javac {0}.java 2> err'.format(filename))
      return is_empty_file('err'), readlines('err')

    def compile_py(filename):
        return True, ''

    """
    Compiles a cpp code.
    """
    def compile_cpp(filename, verbose = True):
      if(verbose): print('compiling cpp')
      os.system('> err')
      os.system('g++ -w -O2 -std=c++11 -o {0} {1}.cpp 2> err'.format(filename, filename))
      return is_empty_file('err'), readlines('err')

    """
    Run a cpp code.
    """
    def run_cpp(filename, timelimit, inputfile = 'input', outputfile = 'output', verbose = True):
      if(verbose): print('running cpp')
      os.system('> err')
      start_time = time.clock()
      try:
        subprocess.run('cat {0} | ./{1} > {2} 2> err'.format(inputfile, filename, outputfile), shell = True, timeout = timelimit)
        os.system('echo $? > code.tmp')
        print(read_first_line('code.tmp'))
      except TimeoutExpired:
        return False, is_empty_file('err'), (timelimit + 0.0001), readlines('err')
      end_time = time.clock()
      run_time = end_time - start_time
      return True, is_empty_file('err'), run_time, readlines('err')

    """
    Run a python3 code.
    """
    def run_py(filename, timelimit, inputfile = 'input', outputfile = 'output', verbose = True):
      if(verbose): print('running python')
      os.system('> err')
      start_time = time.clock()
      try:
        subprocess.run('cat {0} | python3 {1}.py > {2} 2> err'.format(inputfile, filename, outputfile), shell = True, timeout = timelimit)
      except TimeoutExpired:
        return False, is_empty_file('err'), (timelimit + 0.0001), readlines('err')
      end_time = time.clock()
      run_time = end_time - start_time
      return True, is_empty_file('err'), run_time, readlines('err')

    """
    Runs a java code on a given input and writes the output in the given
    output file.

    Returns the cpu run-time of that code.
    """
    def run_java(filename, timelimit, inputfile, outputfile):
      os.system('/bin/bash -c "> err"')
      start_time = time.clock()
      try:
        subprocess.run('cat {0} | java {1} > {2} 2> err'.format(inputfile, filename, outputfile), shell = True, timeout = timelimit)
      except TimeoutExpired:
        return False, is_empty_file('err'), (timelimit + 0.0001), readlines('err')
      end_time = time.clock()
      run_time = end_time - start_time
      return True, is_empty_file('err'), run_time, readlines('err')

    """
    Judge a python solution.
    """
    def judge_py(filename, checker, timelimit, testdir = './tests',  verbose = True):
      return judge(filename, compile_py, run_py, checker, timelimit, testdir, verbose)

    """
    Judge a cpp solution.
    """
    def judge_cpp(filename, checker, timelimit, testdir = './tests',  verbose = True):
      return judge(filename, compile_cpp, run_cpp, checker, timelimit, testdir, verbose)

    """
    Judge a java solution.
    """
    def judge_java(filename, checker, timelimit, testdir = './tests',  verbose = True):
      return judge(filename, compile_java, run_java, checker, timelimit, testdir, verbose)

    """
    Judge a solution.
    """
    def judge(filename, compile, run, checker, timelimit, testdir = './tests', verbose = True):
      judging = Judging()
      # compile the student solution
      compile_ok, err = compile(filename)
      if not compile_ok:
        if(verbose): print('compilation error')
        # compile error
        judging.set_compile_error(True, format_for_output(err))
        return judging
      if(verbose): print('compilation successful')
      # no compile error, so we run
      test_index = -1
      for fn in os.listdir(testdir):
        if fn.endswith('.in'):
          if(verbose): print('running test {0}'.format(fn))
          test_index += 1
          # get the name of the test case
          name = fn.split('.')[0]
          time_ok, run_ok, time, err = run(filename, timelimit, testdir + '/' + fn, 'output.tmp')
          if(verbose): print('run finished: {0}s'.format(time))
          # add the test
          judging.add_test(test_index)
          judging.add_time(test_index, time)
          if not run_ok:
            if(verbose):
              print('runtime error')
              print(err)
            # runtime error
            judging.add_runtime_error(test_index, format_for_output(err))
          elif not time_ok:
            if(verbose): print('time limit exceeded')
            # time limit exceeded
            judging.add_time_limit_exceeded(test_index)
          else:
            if(verbose): print('chicking the answer')
            # check whether the answer is correct
            answer_ok = checker(testdir + '/' + fn, testdir + '/' + name + '.ans', 'output.tmp')
            if not answer_ok:
              if(verbose): print('wrong answer')
              # wrong_answer
              judging.add_wrong_anser(test_index)
            else:
              if(verbose): print('correct')
              # correct
              judging.add_correct(test_index)
      if(verbose): print('finished judging')
      return judging


    class Judging:

      def __init__(self):
        self.compile_error = False
        self.compile_message = None
        self.wrong_answer = set()
        self.time_limit_exceeded = set()
        self.runtime_error = { }
        self.correct = set()
        self.run_time = { }
        self.tests = set()

      def set_compile_error(self, compile_error, compile_message):
        self.compile_error = compile_error
        self.compile_message = compile_message

      def add_wrong_anser(self, test_index):
        self.wrong_answer.add(test_index)

      def add_time_limit_exceeded(self, test_index):
        self.time_limit_exceeded.add(test_index)

      def add_runtime_error(self, test_index, message):
        self.runtime_error[test_index] = message

      def add_time(self, test_index, time):
        self.run_time[test_index] = time

      def add_correct(self, test_index):
        self.correct.add(test_index)

      def add_test(self, test_index):
        self.tests.add(test_index)

      def is_accepted(self):
        return not self.is_compile_error() and not self.is_wrong_answer() and not self.is_time_limit_exceeded() and not self.is_runtime_error()

      def is_wrong_answer(self):
        return len(self.wrong_answer) > 0

      def is_time_limit_exceeded(self):
        return len(self.time_limit_exceeded) > 0

      def is_runtime_error(self):
        return len(self.runtime_error) > 0

      def is_compile_error(self):
        return self.compile_error

      def get_max_runtime(self):
        m = -1
        for test_index in self.tests:
          m = max(m, self.run_time[test_index])
        return m

      def produce_contest_feedback_message(self):
        if self.is_compile_error(): return 'Compile error\n\n'
        if len(self.wrong_answer) > 0: return 'Wrong answer\n\n'
        if len(self.runtime_error) > 0: return 'Runtime error\n\n'
        if len(self.time_limit_exceeded) > 0: return 'Time limit exceeded\n\n'
        assert self.is_accepted()
        return 'Accepted'


      def produce_feedback_message(self):
        if self.is_compile_error():
          return 'Compile error\n\n' + self.compile_message
        s = ''
        s += str(self.wrong_answer) + '\n\n'
        s += str(self.time_limit_exceeded) + '\n\n'
        s += str(self.runtime_error) + '\n\n'
        for test_index in self.tests:
          status = ''
          if test_index in self.correct:
            status = '[CORRECT]'
          if test_index in self.wrong_answer:
            status += '[WA]'
          if test_index in self.time_limit_exceeded:
            status += '[TLE]'
          if test_index in self.runtime_error:
            status += '[RE]'
          s += 'Test #{0}: status={1}\n\n'.format(test_index + 1, status)
          if test_index in self.runtime_error:
            s += self.runtime_error[test_index] + '\n\n'
        overall_status = 'verdict: '
        if self.is_accepted():
          overall_status = '[ACCEPTED]'
        if self.is_wrong_answer():
          overall_status += '[WRONG ANSWER]'
        if self.is_time_limit_exceeded():
          overall_status += '[TIME LIMIT EXCEEDED]'
        if self.is_runtime_error():
          overall_status += '[RUNTIME ERROR]'
        s += overall_status
        return s
accessible: true
author: ''
context: |-
    In this task we will see that the same problem can have several DP formulations that can be more suited for some situations.

    Recall that we defined previously the DP subproblems as:

      :math:`dp(i, c)` is the maximum value we can obtain by
      selecting a subset of the objects :math:`0, 1 \ldots, i`
      from a knapsack of capacity :math:`c`.

    Note that we are basing ourselves on the bottom-up formulation.

    But this is not the only way the DP subproblems can be formulation. An alternative is to have the states depend on the value instead of the capacity. We define the states as pairs :math:`(i, v)` and the subproblems as:

      :math:`dp(i, v)` is the minimum knapsack capacity needed in order
      to achieve value :math:`v` from selecting a subset of the objects
      :math:`0, 1 \ldots, i`.

    If a value :math:`v` is impossible to achieve, we define :math:`dp(i, v) = \infty` for all :math:`i`.

    To relate the subproblems and define the recurrence relation we need to think about what happens depending on whether we decide to skip or take the :math:`i`-th item.

    - *If we don't take item* :math:`i` then then minimum kapacity needed to achieve value :math:`v` with items :math:`0, \ldots, i` is the same as for items :math:`0, \ldots, i - 1`. Thus, this in case, :math:`dp(i, v) = dp(i - 1, v)`.

    - *If we take item* :math:`i` then we need capacity :math:`w_i` plus the minimum capacity to achieve value :math:`v - v_i` using items :math:`0, \ldots, i - 1`. Thus, in this case, :math:`dp(i, v) = w_i + dp(i - 1, v - v_i)`. Note that this option is undefined if :math:`v - v_i < 0`. To simplify the formulas, we will assume that, in those case, it evaluates to :math:`\infty`.

    Therefore we can write that :math:`dp(i, v)` is the minimum of those two options:

    .. math::

       dp(i, v) = \min (dp(i - 1, v), w_i + dp(i - 1, v - v_i))

    The base cases are when :math:`i = 0`. In this case the only achievable values are :math:`0` with a knapsack of capacity :math:`0` and :math:`v_0` with a knapsack of capacity :math:`w_0`. Hence, :math:`dp()`

    .. math::

        dp(0, v) =
        \begin{cases}
          0      & \quad \text{if } v = 0 \\
          w_0      & \quad \text{if } v = v_0 \\
          \infty  & \quad \text{if } v \notin \{0, v_0\}
        \end{cases}

    How to you recover the answer in the end (the value, not the items themselves)? Think about it before reading futher.

    The maximum value that can be achieved will correspond to the maximum :math:`v` for which :math:`dp(n - 1, v)` is smaller than or equal to the knapsack capacity.

    With this formulation the number of states is :math:`O(n \cdot V)` where :math:`V = v_0 + v_1 + \ldots + v_{n - 1}`. We can also write it as :math:`O(n^2 \cdot m_v)` where :math:`m_v = \max_i v_i`. We can do so because :math:`V \leq n \cdot m_v`.

    This can be useful for problems where the knapsack is very big because the time complexity does not depend on the knapsack capacity.
    It also shows that if all values are equal to :math:`1` then the problem can be solved in polynomial time :math:`O(n^2)`. But if you think about is, this is obvious, it is easy to solve it in this case in :math:`O(n \cdot \log(n))`.
environment: pyjavacpp
evaluate: best
groups: false
limits:
    time: '1000'
    output: '100'
    memory: '1000'
name: DP - Knapsack flipping the state formulation
network_grading: false
order: 7
problems:
    file:
        name: Knapsakc with small values
        header: |
            Write a solution for the Knapsack problem. Pay attention the the constraints bellow before designing your solution.

            **Input**

            - One line with two integers :math:`C` and :math:`n` giving the knapsack capacity and the number of items respectively.

            - :math:`n` lines each with two integers :math:`w` and :math:`v` giving the weights and the values of each of the items.

            **Output**

            A single line with an integer giving the maximum value that can be achieve by taking a subset of the items with total weight at most :math:`C`.

            *Do not forget to print the answer as an int and not a double.*

            **Constraints**

            * :math:`1 \leq C, n, v, w \leq 2000`

            **Sample Test Cases**

            `Sample input 1 <dp-knapsack/1.in>`_

            `Sample output 1 <dp-knapsack/1.ans>`_


            `Sample input 2 <dp-knapsack/2.in>`_

            `Sample output 2 <dp-knapsack/2.ans>`_
        type: file
        allowed_exts:
        - .java
        - .cpp
        - .py
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
