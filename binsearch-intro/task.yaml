accessible: false
author: ''
context: |-
    Binary search is a fundamental technique in the development of algorithms and an essential tool in your algorithmist toolkit.

    In its most pure form, binary search is used to find an element in a sorted array. So let's start by solving that problem.

        Given a sorted array :math:`a` of :math:`n` integers, how can we efficiently determine whether it contains a given target element :math:`t`?

    Denote by :math:`a[i:j]` the subarray of :math:`a` from indexes :math:`i` to :math:`j` (inculive), that is, :math:`a[i], a[i + 1], \ldots, a[j]`.

    Let's say we check element at position :math:`i`. If :math:`a[i] = t` then we can report that :math:`a` contains :math:`t` at position :math:`i`. Otherwise, we either have :math:`a[i] < t` or :math:`a[i] > t`.

    Since :math:`a` is sorted, if :math:`a[i] < t` then we know that all elements before index :math:`i`, that is, :math:`a[0], a[1], \ldots, a[i - 1]` are also smaller than :math:`t`. Hence we can discard them and save us the trouble of comparing all of the against :math:`t`. In other words, we recuded the problem of finding :math:`t` in :math:`a` to the problem of finding :math:`t` in :math:`a[i+1:n-1]`.

    On the other case, when :math:`a[i] > t` we can apply an analogous reasoning to discard all elements after index :math:`i`.

    **Conclusion:** by checking any index :math:`i` we will either find :math:`i` or be able to discard all indexes smaller than :math:`i` or all indexes greater than :math:`i`. If we select :math:`i` to be the middle index, then we are sure that, in the worse case, we can discard *half* of the elements of the array.

    But then what do we do once we discarded half of the array?

    We can repeat the same process recursivelly on the new smaller array and discard half again and so on until either we find :math:`t` or we discard all elements of the array.

    In order to avoid copying the subarrays, we will simply keep track of the index of the first and last elements of the array. Call them :math:`L` and :math:`R`, respectivelly. In the begining we start with :math:`L = 0` and :math:`R = n - 1`. The middle element can be computed as

    .. math::

        M = (L + R) / 2

    where the division stands for integer divison (so that for instance 5 / 2 = 2 and not 2.5).

    By what we said above, if :math:`a[M] < t` then we can discard the lower half of the array. This can be achieve by setting :math:`L` to :math:`M + 1`. If :math:`a[M] > t` then we can discard the upper half of the array by setting :math:`R` to :math:`M - 1`. We stop when the array becomes empty, that is, when :math:`L > R`, returnin :math:`-1` indicating that :math:`t` is not an element of :math:`a`.

    In code we get the following:

    .. code:: java

        // iterative implementation
        static int binSearch(int[] a, int t) {
            int L = 0;
            int R = a.length - 1;
            while(L <= R) {
                int M = (L + R) / 2;
                if(a[M] == t) return M;
                if(a[M] < t) L = M + 1;
                if(a[M] > t) R = M - 1;
            }
            return -1;
        }

    You can also implement it recursivelly. Depending on the person, some people find one easier to read than the other.

    .. code:: java

        // recursive implementation
        static int binSearch(int[] a, int t) {
            return binSearchAux(a, t, 0, a.length - 1);
        }

        static int binSearchAux(int[] a, int t, int L, int R) {
            if(L > R) return -1;
            int M = (L + R) / 2;
            if(a[M] < t) return binSearchAux(a, t, M + 1, R);
            if(a[M] > t) return binSearchAux(a, t, L, M - 1);
            return M;
        }

    Whichever you use, should not really matter except that maybe the recursive implementation may have some little overheard because of the recursion stack. In most problems that should not have any impact and you should use the one you feel more comfortable with.
environment: pyjavacpp
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    memory: '1000'
    time: '1000'
name: Binary search - Introduction
network_grading: false
problems:
    file:
        name: ''
        allowed_exts:
        - .java
        - .cpp
        - .py
        header: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
