accessible: false
author: ''
context: |-
    Binary search is a fundamental technique in the development of algorithms and an essential tool in your algorithmist toolkit.

    In its most pure form, binary search is used to find an element in a sorted array. So let's start by solving that problem.

        Given a sorted array :math:`a` of :math:`n` integers, how can we efficiently determine whether it contains a given target element :math:`t`?

    Denote by :math:`a[i:j]` the subarray of :math:`a` from indexes :math:`i` to :math:`j` (inculive), that is, :math:`a[i], a[i + 1], \ldots, a[j]`.

    Let's say we check element at position :math:`i`. If :math:`a[i] = t` then we can report that :math:`a` contains :math:`t` at position :math:`i`. Otherwise, we either have :math:`a[i] < t` or :math:`a[i] > t`.

    Since :math:`a` is sorted, if :math:`a[i] < t` then we know that all elements before index :math:`i`, that is, :math:`a[0], a[1], \ldots, a[i - 1]` are also smaller than :math:`t`. Hence we can discard them and save us the trouble of comparing all of the against :math:`t`. In other words, we recuded the problem of finding :math:`t` in :math:`a` to the problem of finding :math:`t` in :math:`a[i+1:n-1]`.

    On the other case, when :math:`a[i] > t` we can apply an analogous reasoning to discard all elements after index :math:`i`.

    **Conclusion:** by checking any index :math:`i` we will either find :math:`i` or be able to discard all indexes smaller than :math:`i` or all indexes greater than :math:`i`. If we select :math:`i` to be the middle index, then we are sure that, in the worse case, we can discard *half* of the elements of the array.

    But then what do we do once we discarded half of the array?

    We can repeat the same process recursivelly on the new smaller array and discard half again and so on until a single element is left.

    In order to avoid copying the subarrays, we will simply keep track of the index of the first and last elements of the array. Call them :math:`L` and :math:`R`, respectivelly. In the begining we start with :math:`L = 0` and :math:`R = n - 1`. The middle element can be computed as

    .. math::

        M = (L + R) / 2

    where the division stands for integer divison (so that for instance 5 / 2 = 2 and not 2.5).
environment: pyjavacpp
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    memory: '1000'
    time: '1000'
name: Binary search - Introduction
network_grading: false
problems:
    file:
        name: ''
        allowed_exts:
        - .java
        - .cpp
        - .py
        header: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
