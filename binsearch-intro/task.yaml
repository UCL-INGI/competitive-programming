accessible: false
author: ''
context: |-
    Binary search is a fundamental technique in the development of algorithms and an essential tool in your algorithmist toolkit.

    In its most pure form, binary search is used to find an element in a sorted array. So let's start by solving that problem.

        Given a sorted array :math:`a` of :math:`n` integers, how can we efficiently determine whether it contains a given target element :math:`t`?

    Denote by :math:`a[i:j]` the subarray of :math:`a` from indexes :math:`i` to :math:`j` (inculive), that is, :math:`a[i], a[i + 1], \ldots, a[j]`.

    Let's say we check element at position :math:`i`. If :math:`a[i] = t` then we can report that :math:`a` contains :math:`t` at position :math:`i`. Otherwise, we either have :math:`a[i] < t` or :math:`a[i] > t`.

    Since :math:`a` is sorted, if :math:`a[i] < t` then we know that all elements before index :math:`i`, that is, :math:`a[0], a[1], \ldots, a[i - 1]` are also smaller than :math:`t`. Hence we can discard them and save us the trouble of comparing all of the against :math:`t`. In other words, we recuded the problem of finding :math:`t` in :math:`a` to the problem of finding :math:`t` in :math:`a[i+1:n-1]`.
environment: pyjavacpp
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    memory: '1000'
    time: '1000'
name: Binary search - Introduction
network_grading: false
problems:
    file:
        name: ''
        allowed_exts:
        - .java
        - .cpp
        - .py
        header: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
