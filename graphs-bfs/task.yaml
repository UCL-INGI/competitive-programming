accessible: true
author: ''
context: |-
    In this task we are going to extend our path finding algorithm and show how we can compute the distances from a given node :math:`s` to every other node.

    In this context, the distance between two nodes is defined as the minimum number of edges in any path between them. Later, we will consider weights on the edges and see how to compute shortest paths, that is, paths such that the sum of the weights of the edges is a small as possible. You can think of this case as a specification of the general shortest path problem when all edge weights are equal to :math:`1`.

    We will see that the path finding algorithm already has everything that we need in order to be able to compute the distances. To see this, we will execute the algorithm again on the same graph but drawing it in a way that the nodes are organized by distance layers. That is one layer for nodes at distance 0, one for nodes at distance 1, and so on.

    Take the previous graph and label each node with its distance from node :math:`s = 0` and redraw it by placing the nodes that have the same distance on the same layer as show in the following figure.

    .. image:: graphs-bfs/bfs3.png

    On the left you can see the original graph, in the middle the same graph where each node is labeled with its distance from :math:`s` and, on the right, the same graph but with nodes grouped by distance layers.

    Now we execute again the algorithm but drawing the graph with distance layers:

    .. image:: graphs-bfs/anim.gif

    What do you observe?

    The algorithms vists the node layer by layer! The source node :math`s` is obviously at distance :math:`0`. Everytime a node puts a new node into the queue, the node that was added belongs to the next layer. This means that its distance from :math:`s` is equal to 1 plus the distance of the node that put it into the queue.

    Denote by :math:`distance(u)` the distance from :math:`s` to :math:`u`. Then we can write that if node :math:`u` adds node :math:`v` into the queue it holds

    .. math::

       distance(v) = 1 + distance(u)
environment: correctoz
evaluate: best
groups: false
limits:
    output: '2'
    time: '30'
    memory: '100'
name: Graphs - Breadth first search
network_grading: false
problems:
    file:
        type: file
        header: ''
        name: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
