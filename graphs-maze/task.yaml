accessible: true
author: ''
context: |+
    We are now going to see how we can solve mazes as the one show below. The goal is to find a path in the maze connecting the two blue points.

    |

    .. image:: graphs-maze/maze.png

    |

    We can simply use the path finding algorithm that implemented before. What we are going to learn here is to avoid representing the graph explicitly and execute the path finding algorithm directly on the maze.

    It is easy to represent the maze problem as a path finding problem on a graph. The graph has one node for each white cell in the maze. There is an edge between two nodes if the corresponding white cells are adjacent. The following figure shows and example:

        **Example:**

        .. image:: graphs-maze/maze2.png

        |

        Notice that in this case graph, whenever there is an edge
        :math:`(u, v)` there reverse edge :math:`(v, u)` also exsits.
        This is because if we can go from cell :math:`x` to cell
        :math:`y` we can also move from cell :math:`y` to cell
        :math:`x`. In this case we say that the graph is
        **undirected**. Usually edges in undirected graphs are
        represented by segments as show in the right figure instead of
        having the two arrows. From now on this will be how we represent
        undirected graphs graphically.

    One way to solve this problem is to explicitly build the graph that corresponds to the maze and call :code:`findPath`. However we will not do this. Instead we will re-implement the algorithm to run over the maze without explicitly building the graph.

    We represent the maze as an ascii matrix :math:`maze` using :code:`#` for the walls, :code:`.` for the white space, :code:`S` for the starting point and :code:`T` for the destination.

        **Example:**

        The above maze will be represented by:

        ``#########``

        ``#......S#``

        ``#.#.#####``

        ``#...#...#``

        ``#.#####.#``

        ``#.......#``

        ``#.#####.#``

        ``#.#T....#``

        ``#########``

    Nodes will be represented with array of two elements. So node :math:`u = (i, j)` is represented in code as :code:`int[] u = new int[] {i, j}`.

    When we are at node :math:`(i, j)` we know that our candidate neighbors are:

    .. math::

       (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)

    From these we need to remove the ones that correspond to a wall. To easily iterate over them it is convinient to declare an array with the possible movement directions:

    .. code:: java

        static int[][] dir = new int[][] {
            new int[] {-1, 0},
            new int[] {1, 0},
            new int[] {0, -1},
            new int[] {0, 1}
        };

    Then to iterate over the neighbors of :math:`u = [u_i, u_j]` we can simply do:

    .. code:: java

        for(int[] d : dir) {
            int i = u[0] + d[0];
            int j = u[1] + d[1];
            if(maze[i][j] != '#') {
                // do something, the neighbor (i, j) of u
            }
        }

    Putting these pieces together to make a path finding algorithms is straighforward. As before, we need

environment: pyjavacpp
evaluate: best
groups: false
limits:
    output: '100'
    time: '1000'
    memory: '1000'
name: Graphs - Solving a maze
network_grading: false
problems:
    file:
        allowed_exts:
        - .java
        - .cpp
        - .py
        name: ''
        header: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
