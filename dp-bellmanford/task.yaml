accessible: false
author: ''
context: |-
    In the previous task, we say a DP formulation for the shortest path problem with positive edge weights :math:`w` from a given source node :math:`s`:

    .. math::

        dp(s) = 0

    and for :math:`v \neq s`

    .. math::

        dp(v) = \min_{u \ \textrm{in-neighbor of} \ v} dp(u) + w(u, v)

    The state graph is the same as the input graph and so this formulation will work if and only if the input graph is acyclic.

    So what can we do if the input graph contains cycles, is it still possible to solve it with dynamic programming? *YES*. But we need to change the formulation so that the resulting state graph is acyclic.

    Doing so requires some imagination and is problem dependent. However there are some general tricks.

    Suppose that you have a fomrulation with states :math:`s \in S`.
    Imagine that you add a parameter :math:`i` to the formulation and manage to make sure that each state :math:`(s, i)` **only depends** on states :math:`(s, j)` with :math:`j < i`. Then your new state graph is clearly acyclic since any path on it

    .. math::

        (s_1, i_1), (s_2, i_2), \ldots, (s_k, i_k)

    must has have a strincly increasing :math:`i` coordinates

    .. math::

        i_1 < i_2 < \ldots < i_k

    This might seem a bit abstract so let's see a concrete example with the shortest path problem.

    Define a new state :math:`(v, i)` with the following subproblem definition:

        :math:`dp(v, i)` equals the length of the shortest path from :math:`s` to :math:`v` that traverses at most :math:`i` edges.

    How to the subproblems relate to each other? To reach node :math:`i` using at most :math:`i` edges, we have two possibilities:

    1. We reach some neighbor :math:`u` of :math:`v` using at most :math:`i - 1` edges and then traverse edge :math:`(u, v)`

    2. We reach :math:`v` using at most :math:`i - 1` edges.

    Mathematically, this means that

    .. math::

      dp(v, i) = \min
      \begin{cases}
        \min \left\{ dp(u, i - 1) + w(u, v) \mid \textit{$u$ neighbor $v$} \right\} \\
        dp(v, i - 1)
      \end{cases}

    The base case is when :math:`i = 0`. In this case we only use paths with :math:`0` edges the only node that is reachable from the source :math:`s` is itself. If :math:`d(v, i)` is not defined, that is, the path of at most :math:`i` edges from :math:`s` to :math:`v` exists, we define :math:`d(v, i) = \infty`. In particular, it means that we initialize :math:`d(v, 0) = \infty` for each :math:`v \neq s`.


    With this formulation we can now solve the following problem:

        Given a weighted graph :math:`G` and a source :math:`s`, what is the shortest path from :math:`s` to :math:`v` using at most :math:`i` edges?

    Notice that with positive edge weights, any shortest path uses at most :math:`|V| - 1` edges (such a shortest path cannot have cycles). This means that we only need to compute the answer for states until :math:`i = |V| - 1`. The answer to the shortest path problem from :math:`s` to :math:`v` will therefore be :math:`dp(v, |V| - 1)`.

    What did we lose by extending the space state? We lost efficiency, now there are :math:`O(|V|^2)` states
environment: dafny
evaluate: best
groups: false
input_random: '0'
limits:
    time: '30'
    output: '2'
    memory: '100'
name: 'DP - Shortest paths: Acyclic formulation'
network_grading: false
problems: {}
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
