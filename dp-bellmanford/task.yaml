accessible: false
author: ''
context: |-
    In the previous task, we say a DP formulation for the shortest path problem with positive edge weights :math:`w` from a given source node :math:`s`:

    .. math::

        dp(s) = 0

    and for :math:`v \neq s`

    .. math::

        dp(v) = \min_{u \ \textrm{in-neighbor of} \ v} dp(u) + w(u, v)

    The state graph is the same as the input graph and so this formulation will work if and only if the input graph is acyclic.

    So what can we do if the input graph contains cycles, is it still possible to solve it with dynamic programming? *YES*. But we need to change the formulation so that the resulting state graph is acyclic.

    Doing so requires some imagination and is problem dependent. However there are some general tricks.

    Suppose that you have a fomrulation with states :math:`s \in S`.
    Imagine that you add a parameter :math:`i` to the formulation and manage to make sure that each state :math:`(s, i)` **only depends** on states :math:`(s, j)` with :math:`j < i`. Then your new state graph is clearly acyclic since any path on it

    .. math::

        (s_1, i_1), (s_2, i_2), \ldots, (s_k, i_k)

    must has have a strincly increasing :math:`i` coordinates

    .. math::

        i_1 < i_2 < \ldots < i_k

    This might seem a bit abstract so let's see a concrete example with the shortest path problem.

    Define a new state :math:`(v, i)` with the following subproblem definition:

        :math:`dp(v, i)` equals the length of the shortest path from :math:`s` to :math:`v` that traverses at most :math:`i` edges.

    How to the subproblems relate to each other? To reach node :math:`i` using at most :math:`i` edges, we have two possibilities:

    1. We reach some neighbor :math:`u` of :math:`v` using at most :math:`i - 1` edges and then traverse edge :math:`(u, v)`

    2. We reach :math:`v` using at most :math:`i - 1` edges.

    Mathematically, this means that

    .. math::

      dp(v, i) = \max
      \begin{cases}
        \max \left\{ dp(u, i - 1) + w(u, v) \mid \textit{$u$ neighbor $v$} \right\} \\
        dp(v, i - 1)
      \end{cases}

    The base case is when :math:`i = 0`. In this case we only use paths with :math:`0` edges the only node that is reachable from the source :math:`s` is itself.
environment: dafny
evaluate: best
groups: false
input_random: '0'
limits:
    time: '30'
    output: '2'
    memory: '100'
name: DP - Making a cyclic state graph acyclic (Bellman-Ford)
network_grading: false
problems: {}
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
