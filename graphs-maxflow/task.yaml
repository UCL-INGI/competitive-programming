accessible: false
author: ''
context: |-
    In this task we are going to learn how to compute the maximum flow between two nodes in a graph. In the maximum flow problem each edge has a capacity and we aim at sending the maximum amout of flow (information) between a souce node :math:`s` and a sink node :math:`t` in a graph without exceeding the capacity of any edge.


        **Example:**

        In the following graph, we can send a total of 6 units of flow
        as shown. The numbers on the edges represent the edge
        capacities.

        |

        .. image:: graphs-maxflow/flowEx.png

        |

        In this example all the edges leaving the source are saturated
        (have no capacity remaining). Thus we know that must be the
        maximum flow as we would never be able to send more than this.

    By looking at such an example it seems that we can compute the maximum flow simply by finding paths from :math:`s` to :math:`t`
    and pushing as much as we can each time. As we will see, this is a little too greedy to work so we will need to refine the idea a bit in order for it to work.

        **Example:**

        Consider the same graph but pushing flow on a different set of
        paths. Every time we find a path from :math:`s` to :math:`t` we
        increment the total flow by the minimum capacity edge on that
        path. We label each edge with :math:`f / c` where :math:`f`
        is the flow currently passing on that edge and :math:`c` is its
        capacity.

        |

        .. image:: graphs-maxflow/flowEx2.png

        |

        The first path found was :math:`(s,d,c,t)` and we could push 1
        unit of flow.

        |

        .. image:: graphs-maxflow/flowEx3.png

        |

        Then we found path :math:`(s,a,b,t)` and pushed 3 units of flow.

        |

        .. image:: graphs-maxflow/flowEx4.png

        |

        After that we found path :math:`(s,d,t)` and pushed one more
        unit of flow. Now there are no more paths from :math:`s` to
        :math:`t` with positive capacity in the graph so we cannot push
        more flow.

        |

        .. image:: graphs-maxflow/flowEx5.png

        |

        As you can see, we were only able to push a total of 5 units of     flow. However on the first example we saw that the maximum flow     is 6. This shows that simply finding paths with positive
        capacity and pushing flow does yield an optimal solution.


    This shows that the order in which the paths are selected is important. However, in order to solve the problem, we are not going to develop an algorithm that find a good order. Rather, we will find a cleaver way so that we can reroute some of the flow that we are already sending in order to accomodate new flows.

    Let's look at the final flow that we obtained before and try to understand what we can change in order to send one more unit of flow.

    One way to do that is to first take one unit of flow on :math:`(d, c, t)` and redirect it to :math:`(d, t)` as shown in the following figure:

    |

    .. image:: graphs-maxflow/flowEx6.png

    |

    This will free one new unit over path :math:`(s, a, c, t)`:

    |

    .. image:: graphs-maxflow/flowEx6_2.png

    |


    But how can we find this change? It turns out that a simple path finding algorithm can achieve it. If you think about it, the two operations that we performed, the redirection plus pushing a new unit of flow, is the same as if we had pushed one unit of flow on the following "path":

    |

    .. image:: graphs-maxflow/flowEx7.png

    |

    This is not really a path as edge :math:`(d, c)` is traversed in the opposit direction. However if we defined that when we push flow on an edge, if the edge direction is correct then we **increase** the flow and when direction is reversed,  we **decrease** the flow, the two operations achieve the same exact flow.

    |

    .. image:: graphs-maxflow/flowEx8.png

    |

    The intuition behind this is that the part of the path until we cross an edge in the reverse direction corresponds to the new path on which we will push flow and the part of the path after the edge in reverse direction corresponds to where we redirect the flow.

    This is just a high level intuition as in practice the path could cross several edges in the reverse direction but the idea remains the same.

    So how do we implement all this?

    For every edge in the input graph, we will create a residual edge with the reverse direction initially with capacity :math:`0`. Then whenever we push flow :math:`f` on one edge :math:`e`, we decrease the capacity of :math:`e` by :math:`f` and incrase the capacity of :math:`residual(e)` by :math:`f`. This will allow us to find paths that traverse edges in reverse direction allowing us to redirect the flow passing on it towards another path. We call this modified graph the *residual graph*.

        **Example:**

        Lets look at the residual network corresponding to the above      graph where we were only able to push :math:`5` units of flow.
        We will draw the residual edges in gray to help distinguish     them from the original edges.

        |

        .. image:: graphs-maxflow/flowEx10.png

        |

        You can see that the capacities of the residual edges
        correspond to the amout of flow that is passing and the
        capacities of the original edges correspond to the original
        capacity minus the current flow. Thus, *in the residual graph*
        we have:

        - capacity of :math:`residual(e) = flow(e)`
        - capacity of :math:`e = initialCapacity(e) - flow(e)`

        Using the residual graph, we can now very easily find new ways
        to push flow, we simply have to find a path of positive
        capacity from :math:`s` to :math:`t`. This can be achieve using
        any path finding algorithm that we saw before.

        The following figure show that the strange "path" that we used
        before now correspond to a normal path in the residual graph.

        .. image:: graphs-maxflow/flowEx11.png

        |

        If we push one unit of flow on this path we indeed obtain the
        same flow as before and now we get a residual graph that
        contains no paths from :math:`s` to :math:`t` of positive
        capacity.

        .. image:: graphs-maxflow/flowEx12.png

        |

        In can be shown that when no more paths exist between the
        source and the destination in the residual graph then we have a
        maximum flow.

    We are now going to see how we can implement this. The implementation that we will see here is not the most common or succinct but we believe that it is the one that is the closest to what we describe. We will proivde later shorter implementations that are more aimed at competitive programming.

    The first thing that we need is a way to represent the edges. For this we create a simple :code:`FlowEdge` class containing the edge information: the origin node, the destination node, its capacity and a pointer to the residual edge.

    .. code:: java

        static class FlowEdge {

            FlowEdge residual;
            int orig, dest, cap;

            public FlowEdge(int u, int v, int cap) {
                this.orig = u;
                this.dest = v;
                this.cap = cap;
            }

            public void push(int flow) {
                cap -= flow;
                residual.cap += flow;
            }

        }
environment: mcq
evaluate: best
groups: false
input_random: '0'
limits:
    memory: '100'
    output: '2'
    time: '30'
name: Graphs - Maximum flow
network_grading: false
order: 0
problems:
    file:
        type: file
        header: ''
        name: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
