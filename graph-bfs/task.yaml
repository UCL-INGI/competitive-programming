accessible: true
author: ''
context: |+
    In this task we will focus on the problem of finding a path between two given nodes in a graph.

    Let :math:`s` be the source node and :math:`t` the destination node.
    We will keep which nodes have already been visited and which nodes still need to be processed in a queue. At each iteration we pick the node in front of the queue to be processed and add all of its unvisited neighbors to the queue of nodes to process. If we continue in this way until there are no more nodes to process then we know that there is path from :math:`s` to :math:`t` if and only if :math:`t` was visited.

      Example:

      The following figure shows an execution of the this process with
      :math:`s = 0`.

      .. image:: graph-bfs/bfs.png

environment: pyjavacpp
evaluate: best
groups: false
limits:
    output: '100'
    time: '1000'
    memory: '1000'
name: Graph - Finding a path
network_grading: false
problems:
    file:
        allowed_exts:
        - .java
        - .cpp
        - .py
        type: file
        header: ''
        name: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
