accessible: true
author: ''
context: |-
    The solution that we developed for the Knpasack problem where we solve our problem with a recursive function and memoize the results is called **top-down** dynamic programmig.

    There is another way to implement a DP algorithm which is called **bottom-up**. In most cases the choice of which one you use should be based on the one you are more comfortable writting. Personally I feel that top-down DP is more intuitive but this varies from one person to another.

    You should most both ways and be able to switch between them easily as in some cases one is more efficient than the other. We will see examples of this in more advanced DP problems.

    For now let's explain what bottom-up DP consists of and write such a solution for the Knapsack problem.

    In our previous solution we defined the DP subproblems

    In bottom-up DP we will write an iterative solution to compute the value of *every* state. We will start from the smallest subproblems and iterativelly increase the size and compute the new solutions from the ones we already know. The smallest (or easiest) subproblems correspond to the case where we only have one item.

    that computes :math:`dp(i, c)` for all :math:`i` and :math:`c`.
environment: scapy
evaluate: best
groups: false
limits:
    time: '30'
    output: '2'
    memory: '100'
name: DP - Top down VS Bottom up
network_grading: false
order: 2
problems:
    dp-topdown-bottomup:
        header: ''
        name: Mark this section as read?
        limit: 0
        choices:
        -   valid: true
            text: Yes.
        type: multiple-choice
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
weight: 1.0
