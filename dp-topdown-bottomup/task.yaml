accessible: true
author: ''
context: |-
    The solution that we developed for the Knpasack problem where we solve our problem with a recursive function and memoize the results is called **top-down** dynamic programmig.

    There is another way to implement a DP algorithm which is called **bottom-up**. In most cases the choice of which one you use should be based on the one you are more comfortable writting. Personally I feel that top-down DP is more intuitive but this varies from one person to another.

    You should most both ways and be able to switch between them easily as in some cases one is more efficient than the other. We will see examples of this in more advanced DP problems.

    For now let's explain what bottom-up DP consists of and write such a solution for the Knapsack problem.

    In our previous solution we defined the DP subproblems

    In the top-down DP solution we defined the states and subproblems starting from the problem that we want to solve. That is, having all objects available and a knapsack of capacity :math:`C`.

    In bottom-up DP we will write an iterative solution to compute the value of *every* state. We will start from the smallest subproblems and iterativelly increase the size and compute the new solutions from the ones we already know. This means that we will have to redefine the subproblems. Then we will need to find how the solution of the problem changes when a new object becomes available.

    We define the subproblems as follows:

      :math:`dp(i, c)` is the maximum value we can obtain by
      selecting a subset of the objects :math:`0, 1 \ldots, i`
      from a knapsack of capacity :math:`c`.

    Notice that now when we increase :math:`i` we are considering more objects whereas in the previous definitions it would consider less objects.

    The easy suproblems correspond to states where :math:`i = 0`,, that is, we only have one object. In this case we either get value :math:`v_0` if object fits the knapsack or 0 otherwise.

    .. math::

       dp(0, c) =
       \begin{cases}
       v_0       & \quad \text{if $v_0 \leq c$}\\
       0 & \quad \text{otherwise}
      \end{cases}

    Now we need to express the solution of :math:`dp(i, c)` with the values of smaller subproblems. In this case, subproblems :math:`(i',  c')` where :math:`i' \leq i` and :math:`c' \leq c`.
environment: scapy
evaluate: best
groups: false
limits:
    time: '30'
    output: '2'
    memory: '100'
name: DP - Top down VS Bottom up
network_grading: false
order: 2
problems:
    dp-topdown-bottomup:
        header: ''
        name: Mark this section as read?
        limit: 0
        choices:
        -   valid: true
            text: Yes.
        type: multiple-choice
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
weight: 1.0
