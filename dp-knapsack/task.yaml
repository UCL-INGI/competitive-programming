accessible: true
author: ''
context: |+
    In the Knapsack problem, you are given :math:`n` objects each one with a given integer weight :math:`w_i` and value :math:`v_i`. You can take a subset of these objects such that the sum of their weights is at most a given capacity value :math:`C`. The goal is to maximize the total value of the selected items.

      **Example**

      Consider the knapsack with capacity 15 and the items shown in the
      following figure.

      .. image:: dp-knapsack/knapsack.png

      *Image source: wikipedia*

      The optimal solution is to take all items except the green one.
      The total weight is :math:`1 + 4 + 1 + 2 = 8 \leq 15` and the
      total value is :math:`2 + 10 + 1 + 2 = 15`.

    In order to solve this problem with dynamic programming we first need to think about it as a sequence of choices. What are the choices we are making here?

    For each item we have two options: either we take it or we don't. So far so good. The next step is to think about what information to we need to keep track of in order to decide whether a choice is possible? Do we need to know what items were taken so far?

    No. The exact set of items taken so far is too much information, all we need to know is the remaining capacity in the knapsack. If the remaining capacity is larger than or equal to the weight of the object we are deciding on, then we can take either take it or not take it. Otherwise we are forced to not take it.

    Also, observe that the order in which the decisions are made does not matter. If a set of objects fits into the knapsack, it does not matter in which order you decided to put them, only the total weight matters.

    This suggests that we go through the objects one by one, in the order in which they are given and for each of them make a decision. Given what we said above this means that we need to keep track of two pieces of information:

    1. The index of the current item :math:`i`
    2. The remaining capacity :math:`c`

    We call such a pair :math:`(i, c)` a *subproblem*. The meaning of the subproblem :math:`(i, c)` is:

      what is the maximum value we can obtain by selecting a subset of
      the items :math:`i, i + 1, \ldots, n - 1` from a knapsack of
      capacity :math:`c`?

    The original problem is described by the subproblem :math:`(0, C)` since it represents the maximum value we can obtain by selecting a subsets of all items on a knapsack of capacity :math:`C`.

    The next step is to think how the subproblems relate to each other. For that we need to look at the *choices* that we have at each state.

    - *If we do not take item 0* then we go to state :math:`(1, C)`. This is because the next step is to make the decision of item 1 and the capacity of the knapsack remains unchanged since we did not put any item in it.
    - *If we take item 0* then go to state :math:`(1, C - w_0)` because we now have to make a decision for item :math:`1` but on a knapsack with capacity :math:`C - w_0` since item 0 is inside the knapsack.


environment: python3
evaluate: best
groups: false
limits:
    output: '2'
    memory: '100'
    time: '30'
name: DP - Knapsack
network_grading: false
problems:
    dp-knapsack-1:
        header: ''
        type: code-file
        name: Knapsack
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
weight: 1.0
