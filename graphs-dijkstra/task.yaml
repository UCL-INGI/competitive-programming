accessible: false
author: ''
context: |
    Dijkstra's algorithm is an algorithm to compute shortest paths in graphs with **non-negative** edge weights. Denote by :math:`w(u, v)` the weight of edge :math:`(u, v)`.

    As BFS, we will design the algorithm to receive a source node :math:`s` as input and compute the shortest path distances to each other node in the graph.

    Let :math:`dist` be an array such that :math:`dist[v]` is equal to the shortest path distance between node :math:`s` and node :math:`v`.
    The idea of Dijkstra's algorithm is to keep a set of nodes :math:`S` for which we know the value of :math:`dist` and grow it until :math:`S = V`.

    Since there are no negative edge weights, we know that :math:`dist[s] = 0`. This means that we can initialize :math:`S = \{s \}`. For the other nodes, we initially set :math:`dist[v] = \infty`.

    Given the set :math:`S`, how can we find a new node to add to it and its distance?

    We will consider all edges that go from a node in :math:`S` to a node outside of :math:`S`. From all such edges, we will pick an edge :math:`(u, v)` such that :math:`dist[u] + w(u, v)` is **minimum**. Then, it is not hard to see that, :math:`dist[v] = dist[u] + w(u, v)`.

    To convince yourself that this is indeed the case, imagine that there is a better way of reaching :math:`v`. Since :math:`s \in S` and :math`v \notin S`, this alternative path must at some point exit the set :math:`S`. Suppose that it does to by an edge :math:`(x, y)` other than :math:`(u, v)`. The following figure illustrates the situation:

    .. image:: graphs-dijkstra/dijkstra1.png

    |

    Then, the path (show in orange) will have the form :math:`(s, \ldots, x, y, \ldots, v)`. Its cost will be

    .. math::

        dist[x] + w(x, y) + cost(x, y)

    where

    - :math:`dist[x]` is the cost of reaching :math:`x` from :math:`s`
    - :math:`w(x, y)` is the cost of edge :math:`(x, y)`
    - :math:`cost(x, y)` is the cost of the path from :math:`x` to :math:`y`

    On the other hand, the blue path has cost:

    .. math::

        dist[u] + w(u, v)

    And we must have

    .. math::

        dist[u] + w(u, v) \leq dist[x] + w(x, y) + cost(x, y)

    because we selected :math:`u` such that :math:`dist[u] + w(u, v) \leq dist[x] + w(x, y)` and we know that, since the edge weights are non-negative, :math:`cost(x, y) \geq 0`.
environment: java8scala
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    time: '1000'
    memory: '1000'
name: Graphs - Dijkstra
network_grading: false
problems:
    file:
        language: ''
        name: ''
        default: ''
        header: ''
        type: code
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
