accessible: false
author: ''
context: |-
    Dijkstra's algorithm is an algorithm to compute shortest paths in graphs with **non-negative** edge weights. Denote by :math:`w(u, v)` the weight of edge :math:`(u, v)`.

    As BFS, we will design the algorithm to receive a source node :math:`s` as input and compute the shortest path distances to each other node in the graph.

    Let :math:`dist` be an array such that :math:`dist[v]` is equal to the shortest path distance between node :math:`s` and node :math:`v`.
    The idea of Dijkstra's algorithm is to keep a set of nodes :math:`S` for which we know the value of :math:`dist` and grow it until :math:`S = V`.

    Since there are no negative edge weights, we know that :math:`dist[s] = 0`. This means that we can initialize :math:`S = \{s \}`. For the other nodes, we initially set :math:`dist[v] = \infty`.

    Given the set :math:`S`, how can we find a new node to add to it and its distance?

    We will consider all edges that go from a node in :math:`S` to a node outside of :math:`S`. From all such edges, we will pick an edge :math:`(u, v)` such that :math:`dist[u] + w(u, v)` is **minimum**. Then, it is not hard to see that, :math:`dist[v] = dist[u] + w(u, v)`.

    To convince yourself that this is indeed the case, imagine that there is a better way of reaching :math:`v`. Since :math:`s \in S` and :math`v \notin S`, this alternative path must at some point exit the set :math:`S`. Suppose that it does to by an edge :math:`(x, y)` other than :math:`(u, v)`. The following figure illustrates the situation:

    .. image:: graphs-dijkstra/dijkstra1.png

    |

    Then, the path (show in orange) will have the form :math:`(s, \ldots, x, y, \ldots, v)`. Its cost will be

    .. math::

        dist[x] + w(x, y) + cost(x, y)

    where

    - :math:`dist[x]` is the cost of reaching :math:`x` from :math:`s`
    - :math:`w(x, y)` is the cost of edge :math:`(x, y)`
    - :math:`cost(x, y)` is the cost of the path from :math:`x` to :math:`y`

    On the other hand, the blue path has cost:

    .. math::

        dist[u] + w(u, v)

    And we must have

    .. math::

        dist[u] + w(u, v) \leq dist[x] + w(x, y) + cost(x, y)

    because we selected :math:`u` such that :math:`dist[u] + w(u, v) \leq dist[x] + w(x, y)` and we know that, since the edge weights are non-negative, :math:`cost(x, y) \geq 0`.

    After this discussion it should be quite straighforward for you implement Dijkstra's algorithm. The high level ideas is the follwoing:

    1. Initialize :math:`dist[s] = 0` and :math:`dist[v] = \infty` for each :math:`v \neq s`
    2. Set :math:`S = \{s\}`
    3. While :math:`S \neq V`, pick :math:`(u, v) \in E` such that :math:`u \in S, v \notin S` and :math:`dist[u] + w(u, v)` is minimum and set :math:`dist[v] = dist[u] + w(u, v)`.

    Now the only question is how fast can we perform the edge selection in step 3. The naive way of doing so is to simply loop over each node :math:`u \in S` and each edge out of :math:`u` to check the condition and get the minimum. This would cost :math:`O(|E|)` making the algorithm run in :math:`O(|V| |E|)` since there are :math:`|V|` iterartions.

    A more efficient alternative is to use a *priority queue*. A priority queue enables to maitain a queue of ordered elements an retreive the minimal element in the order efficiently. In our context, the elements will be the edges sorted by their value of :math:`dist[u] + w(u, v)`.
environment: java8scala
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    time: '1000'
    memory: '1000'
name: Graphs - Dijkstra
network_grading: false
problems:
    file:
        language: ''
        name: ''
        default: ''
        header: ''
        type: code
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
