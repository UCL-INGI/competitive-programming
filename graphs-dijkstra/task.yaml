accessible: false
author: ''
context: |+
    Dijkstra's algorithm is an algorithm to compute shortest paths in graphs with **non-negative** edge weights.

    As BFS, we will design the algorithm to receive a source node :math:`s` as input and compute the shortest path distances to each other node in the graph.

    Let :math:`dist` be an array such that :math:`dist[v]` is equal to the shortest path distance between node :math:`s` and node :math:`v`.
    The idea of Dijkstra's algorithm is to keep a set of nodes :math:`S` for which we know the value of :math:`dist` and grow it until :math:`S = V`.

    Since there are no negative edge weights, we know that :math:`dist[s] = 0`. This means that we can initialize :math:`S = \{s \}`. For the other nodes, we initially set :math:`dist[v] = \infty`.

    Given the set :math:`S`, how can we find a new node to add to it and its distance?

    We will consider all edges that go from a node in :math:`S` to a node outside of :math:`S`. From all such edges, we will pick an edge :math:`(u, v)` such that :math:`dist[u]` is **minimum**. Then, it is not hard to see that :math:`dist[v] = dist[u] + w(u, v)`.



        Let :math:`S` a set of nodes for which we know the :math:`dist[v]`. Let :math:`E(S)` be the set of all edges linking a node in :math:`S` to a node outside of :math:`S`. Then if

    .. image:: graphs-dijkstra/dijkstra1.png

    The idea is that we will explore the graph while keeping an array :math:`dist` representing shortest path distance and satisfying the following invariant:

        At all times, :math:`dist[v]` is equal to the shortest path distance from :math:`s` to :math:`v` passing only by visited nodes. If :math:`v` is not visited, :math:`dist[v] = \infty`.

    Clearly, one all nodes are visited, our invariant reads:

        :math:`dist[v]` is equal to the shortest path distance from :math:`s`to :math:`v`

    Which is exactly what we want to compute. Now it only remains to find an efficient way to visit all nodes while keeping this condition true.

    At the beggining, we will start with only node :math:`s` being visited. In this case, to satisfy our invariant, we simply need to initialize :math:`dist[s] = 0` and :math:`dist[v] = \infty` for all other nodes. Note that there are no negative edge weights so we are sure that :math:`dist[s] = 0`. Otherwise, this base case could be wrong.

environment: java8scala
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    time: '1000'
    memory: '1000'
name: Graphs - Dijkstra
network_grading: false
problems:
    file:
        language: ''
        name: ''
        default: ''
        header: ''
        type: code
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
