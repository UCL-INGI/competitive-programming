accessible: true
author: ''
context: |-
    In this task we will quickly extended our solution for cumulative 1D sums to cumulative 2D sums. The goal is to be able to answer queries over a fixed :math:`n \times m` matrix :math:`A` which input four integers :math:`0 \leq i_1 \leq i_2 < n`, :math:`0 \leq j_1 \leq j_2 < m` and output the sum of the elements in rows :math:`i_1` to :math:`i_2` and columns :math:`j_1` to :math:`j_2`.

    The idea is very similar to the one we developed for the one dimensional case.

    Define :math:`M[i_1][j_1][i_2][j_2]` such that

    .. math::

      M[i_1][j_1][i_2][j_2] = \sum_{i = i_1}^{i_2} \sum_{j = j_1}^{j_2} A[i][j]

    As before, computing this matrix using the defintion would weild a very slow preprocessing algorithm. To reduce the number of entries that need to be computed to :math:`O(n^2)` we will fix :math:`i_1 = j_1 = 0` and express :math:`M[i_1][j_1][i_2][j_2]` as a function of such entries.

    It is easy to see that if :math:`i_1, j_1 > 0` then

    .. math::

       M[i_1][j_1][i_2][j_2] = M[0][0][i_2][j_2] - M[0][0][i_1 - 1][j_2] - M[0][0][i_2][j_1 - 1] + M[0][0][i_1 - 1][j_1 - 1]
environment: pyjavacpp
evaluate: best
groups: false
limits:
    time: '1000'
    memory: '1000'
    output: '100'
name: 'DP - Data structures: 2D cumulative sums'
network_grading: false
problems:
    file:
        type: file
        allowed_exts:
        - .java
        - .cpp
        - .py
        header: ''
        name: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
