accessible: true
author: ''
context: |+
    Suppose that you have a set of :math:`n` tasks to perform some of which depend on each other. If a task :math:`t` depends on taks :math:`t_1, t_2, \ldots, t_k` then we can only do task :math:`t` after having done all the tasks :math:`t_1, t_2, \ldots, t_k`. We would like to compute an order in which we can perform the tasks.

    The tasks and precedences are naturally modeled by a graph with one node per task and an edge from tast :math:`t_i` to :math:`t_j` if and only if task :math:`t_j` depends on task :math:`t_i`.

        **Example:**

        Consider the simple example of getting dressed. There are some
        clothing items that you cannot put before other. For instance,
        the undershorts must be put before the pants, the socks
        before the shoes and so on.

        The following image shows a graph on the top with a possible
        list of precedences for some items of clothing.

        |

        .. image:: graphs-toposort/topo.png

        |

        The graph on the bottom shown a possible order. We draw the
        edges to make it clear that all of them go from the left to the
        right, meaning that no predecendes are violated.

    |

    We define the in-degree of a node :math:`u` as the number of edges that end in :math:`u` and the out-degree as the number of edges that start at it. They are denoted by :math:`indeg(u)` and :math:`outdeg(u)`, respectively.

    It is easy to see that any topological order must start with a node with in-degree :math:`0` since such a node has no precedences. Then, if we remove that node from the graph the same is true from the resulting graph: the next node can by any node with in-degree :math:`0`. This suggests the following algorithm.

    Compute the in-degree of each node. Put all the nodes with in-degree :math:`0` in a queue to be processed. While there nodes to be processed: select one to process, add it in the next position in the order and delete it by decreasing the in-degree of all of its sucessors while adding new nodes with in-degree :math:`0` to the queue.

    The following animation illustrates an execution of this algorithm on the sample graph given above.

    |

    .. image:: graphs-toposort/anim.gif

environment: pyjavacpp
evaluate: best
groups: false
limits:
    memory: '1000'
    time: '1000'
    output: '100'
name: Graphs - Topological sort
network_grading: false
order: 7
problems:
    file:
        name: ''
        header: ''
        type: file
        allowed_exts:
        - .java
        - .cpp
        - .py
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
