accessible: true
author: ''
context: |+
    Suppose that you have a set of :math:`n` tasks to perform some of which depend on each other. If a task :math:`t` depends on taks :math:`t_1, t_2, \ldots, t_k` then we can only do task :math:`t` after having done all the tasks :math:`t_1, t_2, \ldots, t_k`. We would like to compute an order in which we can perform the tasks.

    The tasks and precedences are naturally modeled by a graph with one node per task and an edge from tast :math:`t_i` to :math:`t_j` if and only if task :math:`t_j` depends on task :math:`t_i`.

        **Example:**

        Consider the simple example of getting dressed. There are some
        clothing items that you cannot put before other. For instance,
        the undershorts must be put before the pants, the socks
        before the shoes and so on.

        The following image shows a graph on the top with a possible
        list of precedences for some items of clothing.

        |

        .. image:: graphs-toposort/topo.png

        |

        The graph on the bottom shown a possible order. We draw the
        edges to make it clear that all of them go from the left to the
        right, meaning that no predecendes are violated.

environment: pyjavacpp
evaluate: best
groups: false
limits:
    memory: '1000'
    time: '1000'
    output: '100'
name: Graphs - Topological sort
network_grading: false
problems:
    file:
        name: ''
        header: ''
        type: file
        allowed_exts:
        - .java
        - .cpp
        - .py
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
