accessible: true
author: ''
context: |+
    In this task we will start looking into ways in which DP is used to stucture data to efficiently answer queries.

    We will start with cumulative sums.

    Given an array :math:`a`, and we want to be able to compute cumulative sums its subarrays efficiently. More formally, given two indexes :math:`i \leq j`, we want to compute the value of

    .. math::

       \sum_{k = i}^{j} a[k] = a[i] + a[i + 1] + \ldots + a[j]


    To simplify the notations, we will denote this sum by :math:`i` to :math:`j` by :math:`S(i, j)`.

    On way to answer such queries in :math:`O(1)` would be to pre-compute a matrix :math:`M` such that :math:`M[i][j] = S(i, j)` and simply retrieve the corresponding entry to answer a query. Done in a naive way this would cost us :math:`O(n^3)` to do since there are :math:`O(n^2)` entries in the matrix and each one take `O(n)` to evaluate. Something like this:

    .. code:: java

        static long[][] naivePreprocess(int[] a) {
            long[][] M = new long[a.length][a.length];
            for(int i = 0; i < a.length; i++) {
                for(int j = i; j < a.length; j++) {
                    for(int k = i; k <= j; k++) {
                        M[i][j] += a[i];
                    }
                }
            }
            return M;
        }

        static long sum(int i, int j, int[][] M) {return M[i][j];}

    A slightly better but still quite slow alternative is see that the :math:`M[i][j]` are related to each other. It is easy to see that,
    if :math:`i < j` then

    .. math::

       M[i][j] = \sum_{k = i}^{j} a[k] = a[i] + \sum_{k = i}^{j - 1} a[k] =
       a[i] + M[i][j - 1].

    Thus,

    .. math::

      M[i][j] =
      \begin{cases}
        a[i]              & \quad \text{if } i = j \\
        a[i] + M[i][j - 1] & \quad \text{if } i < j
      \end{cases}

    allowing us to compute each :math:`M[i][j]` in :math:`O(1)`.

    To relate this to DP, you can think of :math:`M[i][j]` as the subproblem of computing the sum of elements :math:`i` through :math:`j` and the above recurrence relation as the relation between those subproblems.

    But we can do even better!

    To do so, we need to avoid having to precompute :math:`O(n^2)` values. We can actually get away by only compute :math:`O(n)` values. Can you think which values are enought to answer any query?

    We will focus only on the entries :math:`M[0][j]`. With simple algebraic manipulation we can easily relate any :math:`M[i][j]` to :math:`M[0][j]` and :math:`M[0][i - 1]`:

    .. math::

       M[i][j] = \sum_{k = i}^j a[k] =
       \left( \sum_{k = 0}^j a[k] \right) -
       \left( \sum_{k = 0}^{i - 1} a[k] \right) = M[0][j] - M[0][i - 1]

    .. image:: dp-ds-cumsums/acsum.png


environment: pyjavacpp
evaluate: best
groups: false
limits:
    time: '1000'
    memory: '1000'
    output: '100'
name: 'DP - Data structures: cumulative sums'
network_grading: false
problems:
    file:
        type: file
        header: ''
        name: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
