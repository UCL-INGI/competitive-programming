accessible: false
author: ''
context: |-
    We will now show how we can reduce the memory from :math:`O(n \cdot C)` to :math:`O(C)` of the bottom-up DP solution we developed for the Knapsack.

    This technique is not usually necessary in programming contests   but it is nice to know it anyway. It also illustrates one advantage of bottom-up DP compared to top-down DP.

    If we look at the recurrence:

    .. math::

      dp(i, c) = \max
       \begin{cases}
       dp(i - 1, c - w_i)       & \quad \text{take item $i$}\\
       dp(i - 1, c) & \quad \text{skip item $i$}
      \end{cases}

    We can observe that the values of states for a given :math:`i` only depend on the values for :math:`i - 1`. Thus, we don't need to keep
    the full matrix in memory, we only need to keep the last line.

    The straightforward way to implement this is to use a temporary array on which we compute the new values and then update the :math:`dp` array at the end of each iteration as show in the code below.

    .. code:: java

        static int knapsack(int C, int n, int[] w, int [] v) {
            int[] dp = new int[C + 1];
            // initialize the base cases
            for(int c = 0; c < C; c++) {
                dp[c] = c - w[0] >= 0 ? v[0] : 0;
            }
            // loop and apply recurrence
            int[] tmp = new int[C + 1];
            for(int i = 1; i < n; i++) {
                for(int c = 0; c <= C; c++) {
                    int take = c - w[i] >= 0 ? v[i] + dp[c - w[i]] : Integer.MIN_VALUE;
                    int skip = dp[c];
                    tmp[c] = Math.max(take, skip);
                }
                dp = Arrays.copyOfRange(tmp, 0, tmp.length);
            }
            return dp[C];
        }

    However we can actually work directly on a single array :math:`dp` if we do it in a clever way. The advantage is mostly that we get a very compact code.

    The problem of doing straight :code:`dp[c] = Math.max(take, skip);`
    is that it will overwrite the value of the state :math:`(i - 1, c)` with the value of state :math:`(i, c)` and it could be the case that a later state :math:`(i, c')` with :math:`c' > c` also depends on :math:`(i - 1, c)`.

    We can overcome this problem by noticing that that :math:`dp(i, c)` only depends on :math:`dp(i - 1, c')` for :math:`c' \leq c`. Therefore if we compute the states in decreasing order of :math:`c` instead of increasing, we will avoid this problem.

    .. code:: java

        static int knapsack(int C, int n, int[] w, int [] v) {
            int[] dp = new int[C + 1];
            for(int i = 0; i < n; i++) {
                for(int c = C; c >= 0; c--) { // loop in decreasing order
                    int take = c - w[i] >= 0 ? v[i] + dp[c - w[i]] : Integer.MIN_VALUE;
                    int skip = dp[c];
                    dp[c] = Math.max(take, skip);
                }
            }
            return dp[C];
        }


    We can reduce the code further by putting the *take* conditions directly into the for loop for :math:`c`.

    .. code:: java

      static int knapsack(int n, int C, int[] v, int [] w) {
        int[] dp = new int[C + 1];
        for(int i = 0; i < n; i++) {
          for(int c = C; c >= w[i]; c--) { // start from w[i] to avoid if
            dp[c] = Math.max(dp[c], v[i] + dp[c - w[i]]);
          }
        }
        return dp[C];
      }

    |

        **WARNING**

        Condensed code is nice because it take less time to type and
        takes less space in your cheatsheets. However, it is often
        harder to read and makes it more likely that you will forget how
        it works because it requires you to remember some cleaver
        observations.
        Also, is it less customizable. For example, with the above code
        you cannot reconstruct the solution.
environment: pyjavacpp
evaluate: best
groups: false
input_random: '0'
limits:
    output: '100'
    memory: '1000'
    time: '1000'
name: DP - Memory reduction
network_grading: false
order: 16
problems:
    file:
        allowed_exts:
        - .java
        - .cpp
        - .py
        name: ''
        header: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
