/run.py: |
    import sys
    import os
    import checkers
    import time
    import math
    from run_tools import *

    """
    CONFIG
    """
    taskname = 'file'
    solname = 'yunoacsol'
    timelimit = 20
    checker = checkers.diff_check
    """
    END OF CONFIG
    """

    filename = None
    local = False
    if sys.argv[1] == '1':
      local = True
      filename = sys.argv[2]

    if not local:
      from inginious import feedback
      judging  = judge_java('yunoacsol', checker, 10000, './tests')
      max_time = judging.get_max_runtime()
      if max_time > timelimit:
        timelimit += max_time - timelimit

    print('maxtime= {0}'.format(timelimit))

    name = None
    ext = None
    files_before = set()

    if local:
      for fn in os.listdir('./'):
        files_before.add(fn)
      os.system('cp ./private/{0} ./{0}'.format(filename))
    else:
      os.system('getinput {0}:filename > tmp'.format(taskname))
      f = open('tmp', 'r')
      filename = f.readlines()[0].strip()

    ext = filename.split('.')[1]
    name = filename.split('.')[0]

    if(ext == 'java'):
      print('received java solution')
      if not local:
        os.system('getinput {0} > {1}.java'.format(taskname, name))
      judging = judge_java(name, checker, timelimit)
      print('finished judging java')
    elif(ext == 'cpp'):
      print('received cpp solution')
      if not local:
        os.system('getinput {0} > {1}.cpp'.format(taskname, name))
      judging = judge_cpp(name, checker, timelimit)
      print('finished judging cpp')
    elif(ext == 'py'):
      print('received python solution')
      if not local:
        os.system('/bin/bash -c "getinput {0} > {1}.py"'.format(taskname, name))
      judging = judge_py(name, checker, timelimit)
      print('finished judging python')


    if local:
      for fn in os.listdir('./'):
        if not fn in files_before:
          print('deleting {0}'.format(fn))
          os.system('rm ./{0}'.format(fn))
      print(judging.produce_feedback_message())
    else:
      if judging.is_accepted():
        feedback.set_global_result("success")
      else:
        feedback.set_global_result("failed")
      feedback.set_global_feedback(judging.produce_feedback_message())
accessible: true
author: ''
context: |
    We will now show how we can reduce the memory from :math:`O(n \cdot C)` to :math:`O(C)` of the bottom-up DP solution we developed for the Knapsack.

    This technique is not usually necessary in programming contests   but it is nice to know it anyway. It also illustrates one advantage of bottom-up DP compared to top-down DP.

    If we look at the recurrence:

    .. math::

      dp(i, c) = \max
       \begin{cases}
       dp(i - 1, c - w_i)       & \quad \text{take item $i$}\\
       dp(i - 1, c) & \quad \text{skip item $i$}
      \end{cases}

    We can observe that the values of states for a given :math:`i` only depend on the values for :math:`i - 1`. Thus, we don't need to keep
    the full matrix in memory, we only need to keep the last line.

    The straightforward way to implement this is to use a temporary array on which we compute the new values and then update the :math:`dp` array at the end of each iteration as show in the code below.

    .. code:: java

        static int knapsack(int C, int n, int[] w, int [] v) {
            int[] dp = new int[C + 1];
            // initialize the base cases
            for(int c = 0; c < C; c++) {
                dp[c] = c - w[0] >= 0 ? v[0] : 0;
            }
            // loop and apply recurrence
            int[] tmp = new int[C + 1];
            for(int i = 1; i < n; i++) {
                for(int c = 0; c <= C; c++) {
                    int take = c - w[i] >= 0 ? v[i] + dp[c - w[i]] : Integer.MIN_VALUE;
                    int skip = dp[c];
                    tmp[c] = Math.max(take, skip);
                }
                dp = Arrays.copyOfRange(tmp, 0, tmp.length);
            }
            return dp[C];
        }

    However we can actually work directly on a single array :math:`dp` if we do it in a clever way. The advantage is mostly that we get a very compact code.

    The problem of doing straight :code:`dp[c] = Math.max(take, skip);`
    is that it will overwrite the value of the state :math:`(i - 1, c)` with the value of state :math:`(i, c)` and it could be the case that a later state :math:`(i, c')` with :math:`c' > c` also depends on :math:`(i - 1, c)`.

    We can overcome this problem by noticing that that :math:`dp(i, c)` only depends on :math:`dp(i - 1, c')` for :math:`c' \leq c`. Therefore if we compute the states in decreasing order of :math:`c` instead of increasing, we will avoid this problem.

    .. code:: java

        static int knapsack(int C, int n, int[] w, int [] v) {
            int[] dp = new int[C + 1];
            for(int i = 0; i < n; i++) {
                for(int c = C; c >= 0; c--) { // loop in decreasing order
                    int take = c - w[i] >= 0 ? v[i] + dp[c - w[i]] : Integer.MIN_VALUE;
                    int skip = dp[c];
                    dp[c] = Math.max(take, skip);
                }
            }
            return dp[C];
        }


    We can reduce the code further by putting the *take* conditions directly into the for loop for :math:`c`.

    .. code:: java

      static int knapsack(int n, int C, int[] v, int [] w) {
        int[] dp = new int[C + 1];
        for(int i = 0; i < n; i++) {
          for(int c = C; c >= w[i]; c--) { // start from w[i] to avoid if
            dp[c] = Math.max(dp[c], v[i] + dp[c - w[i]]);
          }
        }
        return dp[C];
      }


    **WARNING**

      Condensed code is nice because it take less time to type and
      takes less space in your cheatsheets. However, it is often harder
      to read and makes it more likely that you will forget how it works
      because it requires you to remember some cleaver observations.
      Also, is it less customizable. For example, with the above code
      you cannot reconstruct the solution.
environment: pyjavacpp
evaluate: best
groups: false
limits:
    memory: '1000'
    time: '1000'
    output: '100'
name: DP - Memory reduction
network_grading: false
order: 13
problems:
    file:
        allowed_exts:
        - .java
        - cpp
        - .py
        header: ''
        name: ''
        type: file
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
