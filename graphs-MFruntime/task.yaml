accessible: true
author: ''
context: |-
    The algorithm that we presented in the `maxflow task <graphs-maxflow>`_ is due to Jack Edmonds and Richard Karp and thus named Edmonds-Karp. The idea of finding paths in the residual graph was already know. Their contribution was to show that the algorithm runs in polynomial time if we use BFS to find the paths. These class of algorithms are callled *augmenting path algorithms*.

    In general, it is easy to find an upper bound for the running time an augmenting path algorithm:

    Whenever we are able to find a path, we push at least one new unit of flow. Therefore the total flow is strictly increasing so that we will perform at most :math:`F` path finding iterations, where :math:`F` is the maximum flow. Thus the complexity is :math:`O(F (V + E))` if we use an :math:`O(V + E)` algorithm to find the path such as DFS of BFS.

    |

    However, this is not a very good news as we usually do not want the complexity to depend on the *value* of the answer since it could mean that even on a very small graph with, say :math:`F = 10^{10}`, the algorithm would take forever to run.

    We are going to show that using BFS to find the paths, the runs in :math:`O(V E^2)`. Recall that BFS compute shortest paths (in terms on the number of edges).  The first thing that we need to show is that:

        **Theorem**

        During the exectuion of the algorithm, the distances of the
        nodes from the source never decrease.

    **PROOF**

    Assume that, after pushing flow on a path, the distance of some node was decreased. Denote by :math:`d_{bef}` the BFS distances and :math:`d_{aft}` the distances after. Recall that in the BFS we ignore edges of capacity :math:`0`. Let :math:`v` be the closest node to the source :math:`s` whose distance was decresed. That is :math:`v` is such that:

    1. :math:`d_{aft}(s, v)` is minimum
    2. :math:`d_{aft}(s, v) < d_{bef}(s, v)`

    Let :math:`p = (s, \ldots, u, v)` be a shortest path from :math:`s` to :math:`v` on the residual graph *after* the we pushed the flow. By definition we have that

    .. math::

        d_{aft}(s, v) = d_{aft}(s, u) + 1

    Since :math:`v` is the closest node to :math:`s` whose distance decreased and :math:`u` is closer to :math:`s` than :math:`v`, we know that the distance of :math:`u` *did not decrease*. That is

    .. math::

        d_{bef}(s, u) \leq d_{aft}(s, u)

    We can now show that the capacity of (u, v)
environment: cpp
evaluate: best
groups: false
input_random: '0'
limits:
    memory: '100'
    time: '30'
    output: '2'
name: Graphs - Maximum flow runtime
network_grading: false
problems:
    read:
        choices:
        -   valid: true
            text: 'Yes'
        name: Mark this section as read?
        type: multiple_choice
        limit: 1
        header: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
