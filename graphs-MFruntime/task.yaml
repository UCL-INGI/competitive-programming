accessible: true
author: ''
context: |-
    The algorithm that we presented in the `maxflow task <graphs-maxflow>`_ is due to Jack Edmonds and Richard Karp and thus named Edmonds-Karp. The idea of finding paths in the residual graph was already know. Their contribution was to show that the algorithm runs in polynomial time if we use BFS to find the paths. These class of algorithms are callled *augmenting path algorithms*.

    In general, it is easy to find an upper bound for the running time an augmenting path algorithm:

    Whenever we are able to find a path, we push at least one new unit of flow. Therefore the total flow is strictly increasing so that we will perform at most :math:`F` path finding iterations, where :math:`F` is the maximum flow. Thus the complexity is :math:`O(F (V + E))` if we use an :math:`O(V + E)` algorithm to find the path such as DFS of BFS.

    |

    However, this is not a very good news as we usually do not want the complexity to depend on the *value* of the answer since it could mean that even on a very small graph with, say :math:`F = 10^{10}`, the algorithm would take forever to run.

    We are going to show that using BFS to find the paths, the runs in :math:`O(V E^2)`. Recall that BFS compute shortest paths (in terms on the number of edges). The first thing that we need to show is that:

        **Theorem**

        During the exectuion of the algorithm, the distances of the
        nodes from the source never decrease.

    ----

    **PROOF**

    Assume that, after pushing flow on a path, the distance of some node was decreased. Denote by :math:`d_{bef}` the BFS distances and :math:`d_{aft}` the distances after.

    Let :math:`v` be the closest node to the source :math:`s` whose distance was decresed. That is :math:`v` is such that:

    1. :math:`d_{aft}(s, v)` is minimum
    2. :math:`d_{aft}(s, v) < d_{bef}(s, v)`

    Let :math:`p = (s, \ldots, u, v)` be a shortest path from :math:`s` to :math:`v` on the residual graph *after* the we pushed the flow.

    |

    .. image:: graphs-MFruntime/flowTheory1.png

    |
    |

    **Recall that in the BFS we ignore edges of capacity 0.** Therefore it means that every edge of :math:`p` has positive capacity.

    By definition we have that

    .. math::

        d_{aft}(s, v) = d_{aft}(s, u) + 1

    Since :math:`v` is the closest node to :math:`s` whose distance decreased and :math:`u` is closer to :math:`s` than :math:`v`, we know that the distance of :math:`u` *did not decrease*. That is

    .. math::

        d_{bef}(s, u) \leq d_{aft}(s, u)

    We can now show that the capacity of (u, v) *before* was :math:`0`. If it was not, then it was considered by the BFS and thus, by the triangular inequality, :math:`d_{bef}(s, v) \leq d_{bef}(s, v) + 1`.

    |

    .. image:: graphs-MFruntime/flowTheory2.png

    |
    |

    Therefore

    .. math::

        d_{bef}(s, v) \leq d_{bef}(s, u) + 1 \leq d_{aft}(s, u) + 1 = d_{aft}(s, v)

    This would contradict the fact that the distance of :math:`v` was decreased.

    So we have the following situation:

    Before we pushed the flow, the capacity of :math:`(u, v)` was :math:`0` but after it was not, since it is an edge of :math:`p`. The only way in which this is possible is if flow was pushed on the reverse edge :math:`(v, u)`. Since we only push on shortest paths, we must have :math:`d_{bef}(s, u) = d_{bef}(s, v) + 1`. Hence

    .. math::

        d_{bef}(s, v) = d_{bef}(s, u) - 1 \leq d_{aft}(s, u) - 1 = d_{aft}(s, v) - 2

    So that, :math:`d_{bef}(s, v) \leq d_{aft}(s, v)` contradicting the fact that the distance to :math:`v` decreased.

    ----

    We are now going to use the fact that the distances never decrease to prove the time complexity of the algorithm.

        **Theorem**

        Edmonds-Karp algorithm performs at most :math:`O(VE)` BFS's, that is, calls to :code:`augmentFlowBFS`.

    ----

    **PROOF**

    We say that an edge is **critical** on a path :math:`p` if it is a minimum capacity edge. In other words, it is an edge that will have capacity :math:`0` after we push flow on :math:`p`.

    We are going to bound the number of times an edge can become critical. Let :math:`(u, v)` be any edge in the  graph. Since we find shortest paths to push flow, the first time that :math:`(u, v)` becomes critical we have

    .. math::

        d_{bef}(s, v) = d_{bef}(s, u) + 1
environment: cpp
evaluate: best
groups: false
input_random: '0'
limits:
    memory: '100'
    time: '30'
    output: '2'
name: Graphs - Maximum flow runtime
network_grading: false
problems:
    read:
        choices:
        -   valid: true
            text: 'Yes'
        name: Mark this section as read?
        type: multiple_choice
        limit: 1
        header: ''
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
